import ET
import dataclasses
import enum
from _typeshed import Incomplete
from typing import ClassVar, Dict, List, Optional, Tuple

class Contact:
    email: ClassVar[str] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, name: str, email: str = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class License:
    file: ClassVar[str] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, name: str, file: str = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class UrlType(enum.IntEnum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _unhashable_values_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _value_repr_: ClassVar[wrapper_descriptor] = ...
    bugtracker: ClassVar[UrlType] = ...
    discussion: ClassVar[UrlType] = ...
    documentation: ClassVar[UrlType] = ...
    readme: ClassVar[UrlType] = ...
    repository: ClassVar[UrlType] = ...
    website: ClassVar[UrlType] = ...
    __format__: ClassVar[method_descriptor] = ...
    def _generate_next_value_(self, name, start, count, last_values):
        """
        Generate the next value when not given.

        name: the name of the member
        start: the initial start value or None
        count: the number of existing members
        last_values: the list of values assigned
        """
    @classmethod
    def __init__(cls, value) -> None: ...

class Url:
    branch: ClassVar[str] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, location: str, type: UrlType, branch: str = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class Version:
    def __init__(self, from_string: str = ..., from_list: Incomplete | None = ...) -> None:
        """If from_string is a string, it is parsed to get the version. If from_list
                exists (and no string was provided), it is treated as a version list of
                [major:int, minor:int, patch:int, pre:str]"""
    def _init_from_string(self, from_string: str):
        """Find the first digit in the given string, and send that substring off for
                parsing."""
    def _init_from_list(self, from_list): ...
    def _parse_string_to_tuple(self, from_string: str):
        """We hand-parse only simple version strings, of the form 1.2.3suffix -- only
                the first digit is required."""
    @staticmethod
    def _parse_final_entry(final_string: str) -> Tuple[int, str]:
        """The last value is permitted to contain both a number and a word, and needs
                to be split"""
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...

class DependencyType(enum.IntEnum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _unhashable_values_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _value_repr_: ClassVar[wrapper_descriptor] = ...
    automatic: ClassVar[DependencyType] = ...
    internal: ClassVar[DependencyType] = ...
    addon: ClassVar[DependencyType] = ...
    python: ClassVar[DependencyType] = ...
    __format__: ClassVar[method_descriptor] = ...
    def _generate_next_value_(self, name, start, count, last_values):
        """
        Generate the next value when not given.

        name: the name of the member
        start: the initial start value or None
        count: the number of existing members
        last_values: the list of values assigned
        """
    @classmethod
    def __init__(cls, value) -> None: ...

class Dependency:
    version_lt: ClassVar[str] = ...
    version_lte: ClassVar[str] = ...
    version_eq: ClassVar[str] = ...
    version_gte: ClassVar[str] = ...
    version_gt: ClassVar[str] = ...
    condition: ClassVar[str] = ...
    optional: ClassVar[bool] = ...
    dependency_type: ClassVar[DependencyType] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, package: str, version_lt: str = ..., version_lte: str = ..., version_eq: str = ..., version_gte: str = ..., version_gt: str = ..., condition: str = ..., optional: bool = ..., dependency_type: DependencyType = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class GenericMetadata:
    contents: ClassVar[str] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, contents: str = ..., attributes: Dict[str, str] = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class Metadata:
    name: ClassVar[str] = ...
    version: ClassVar[None] = ...
    date: ClassVar[str] = ...
    description: ClassVar[str] = ...
    icon: ClassVar[str] = ...
    classname: ClassVar[str] = ...
    subdirectory: ClassVar[str] = ...
    freecadmin: ClassVar[None] = ...
    freecadmax: ClassVar[None] = ...
    pythonmin: ClassVar[None] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __init__(self, name: str = ..., version: Version = ..., date: str = ..., description: str = ..., maintainer: List[Contact] = ..., license: List[License] = ..., url: List[Url] = ..., author: List[Contact] = ..., depend: List[Dependency] = ..., conflict: List[Dependency] = ..., replace: List[Dependency] = ..., tag: List[str] = ..., icon: str = ..., classname: str = ..., subdirectory: str = ..., file: List[str] = ..., freecadmin: Version = ..., freecadmax: Version = ..., pythonmin: Version = ..., content: Dict[str, List[Metadata]] = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
def get_first_supported_freecad_version(metadata: Metadata) -> Optional[Version]:
    """Look through all content items of this metadata element and determine what the
        first version of freecad that ANY of the items support is. For example, if it
        contains several workbenches, some of which require v0.20, and some 0.21, then
        0.20 is returned. Returns None if frecadmin is unset by any part of this object."""

class MetadataReader:
    @staticmethod
    def from_file(filename: str) -> Metadata:
        """A convenience function for loading the Metadata from a file"""
    @staticmethod
    def from_bytes(data: bytes) -> Metadata:
        """Read XML data from bytes and use it to construct Metadata"""
    @staticmethod
    def _process_element_tree(root: ET.Element) -> Metadata:
        """Parse an element tree and convert it into a Metadata object"""
    @staticmethod
    def _determine_namespace(root: ET.Element) -> str: ...
    @staticmethod
    def _parse_child_element(namespace: str, child: ET.Element, metadata: Metadata):
        """Figure out what sort of metadata child represents, and add it to the
                metadata object."""
    @staticmethod
    def _parse_contact(child: ET.Element) -> Contact: ...
    @staticmethod
    def _parse_license(child: ET.Element) -> License: ...
    @staticmethod
    def _parse_url(child: ET.Element) -> Url: ...
    @staticmethod
    def _parse_dependency(child: ET.Element) -> Dependency: ...
    @staticmethod
    def _parse_content(namespace: str, metadata: Metadata, root: ET.Element):
        """Given a content node, loop over its children, and if they are a recognized
                element type, recurse into each one to parse it."""
    @staticmethod
    def _create_node(namespace, child) -> Metadata: ...

class MetadataWriter:
    @staticmethod
    def write(metadata: Metadata, path: str):
        """Write the metadata to a file located at path. Overwrites the file if it
                exists. Raises OSError if writing fails."""
    @staticmethod
    def _create_tree_from_metadata(metadata: Metadata) -> ET.ElementTree:
        """Create the XML ElementTree representation of the given Metadata object."""
    @staticmethod
    def _create_list_node(metadata: Metadata, key: str, root: ET.Element): ...
